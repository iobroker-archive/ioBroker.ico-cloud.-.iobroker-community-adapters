{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n//Api Documentation: https://interop.ondilo.com/docs/api/customer/v1/\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport { Api, type PossibleTypes } from './lib/api';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\ninterface myDevice {\n    poolId: number;\n    swVersion: string;\n    hasObjects: Record<string, boolean>;\n    uuid: string;\n}\n\n/**\n * Used to encrypt & decrypt pin. Necessary as long as js-controller can't decrypt for us in array structure.\n *\n * @param key - secret key\n * @param value - value to encrypt/decrypt\n * @returns string - encrypted/decrypted value\n */\nfunction encryptDecrypt(key: string, value: string): string {\n    if (!value || !key) {\n        return value;\n    }\n    let result = '';\n    for (let i = 0; i < value.length; ++i) {\n        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));\n    }\n    return result;\n}\n\nclass IcoCloud extends utils.Adapter {\n    private api?: Api;\n    private pollInterval = 0;\n    private devices: Array<myDevice> = [];\n    private pollTimeout: NodeJS.Timeout | null = null;\n    private unloaded = false;\n    private redirectURI = '';\n    private oauthStateCode = '';\n    private sleeps: NodeJS.Timeout[] = [];\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'ico-cloud',\n        });\n        this.on('ready', this.onReady.bind(this));\n        // this.on('stateChange', this.onStateChange.bind(this));\n        // this.on('objectChange', this.onObjectChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    private async sleep(ms: number): Promise<void> {\n        return new Promise(resolve => {\n            this.sleeps.push(\n                setTimeout(() => {\n                    !this.unloaded && resolve();\n                }, ms),\n            );\n        });\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        //update from daemon to schedule and maybe set random schedule.\n        const instanceObject = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n        if (instanceObject) {\n            let updateConfig = false;\n            if (instanceObject.common.mode !== 'schedule') {\n                instanceObject.common.mode = 'schedule';\n                updateConfig = true;\n            }\n            if (instanceObject.common.schedule === undefined || instanceObject.common.schedule === '59 * * * *') {\n                this.log.info('Default schedule found and adjusted to spread calls better over the full hour.');\n                instanceObject.common.schedule = `${Math.floor(Math.random() * 60)} ${Math.floor(Math.random() * 60)} * * * *`;\n                updateConfig = true;\n            }\n            if (updateConfig) {\n                this.log.debug(`Updating configuration, new schedule: ${instanceObject.common.schedule}`);\n                await this.setForeignObjectAsync(instanceObject._id, instanceObject);\n            }\n        }\n\n        const delay = Math.floor(Math.random() * 30000);\n        this.log.debug(`Delay execution by ${delay}ms to better spread API calls`);\n        await this.sleep(delay);\n\n        if (this.config.refreshToken) {\n            this.api = new Api({\n                accessToken: this.config.accessToken,\n                refreshToken: this.config.refreshToken,\n                log: this.log,\n                storeNewTokens: this.storeNewTokens.bind(this),\n            });\n\n            this.log.debug('updating devices.');\n            try {\n                await this.updateDevices();\n            } catch (e: any) {\n                this.log.info('Could not update devices -> will try to update measurements with known devices anyway.');\n                this.log.debug(`Error: ${e}`);\n            }\n            this.log.debug('updating values.');\n            await this.poll();\n            this.log.debug('All done. Exit.');\n            this.terminate();\n        } else {\n            this.log.info(\n                'Not authorized, yet. Please see configuration. Letting adapter run to process oauth2 callback.',\n            );\n        }\n    }\n\n    private async updateDevices(): Promise<void> {\n        const devices = await this.getDevicesAsync();\n\n        let poolArray: any[];\n        let deleteAllowed = true;\n        try {\n            poolArray = await this.api!.getPools();\n        } catch (e: any) {\n            this.log.warn(\n                `Could not update pool list: ${e}. Trying to update know pools instead. If this happens a lot, try to login again.`,\n            );\n            poolArray = [];\n            for (const device of devices) {\n                if (device.native.id) {\n                    poolArray.push({ id: device.native.id });\n                } else {\n                    this.log.warn(\n                        `Pool ${device?.common?.name as string} is missing device id. Will not be able to update.`,\n                    );\n                    deleteAllowed = false;\n                }\n            }\n        }\n\n        //now get information about each pool.\n        for (const pool of poolArray) {\n            if (pool.id) {\n                try {\n                    const icoDevice = await this.api!.getDevice(pool.id);\n\n                    let found = false;\n                    for (const device of devices) {\n                        const uuid = device._id.split('.').pop();\n                        if (uuid === icoDevice.uuid) {\n                            found = true;\n                            let needsUpdate = false;\n                            if (device.native.poolId !== pool.id) {\n                                needsUpdate = true;\n                                device.native.poolId = pool.id;\n                            }\n                            if (device.native.swVersion !== icoDevice.sw_version) {\n                                needsUpdate = true;\n                                device.native.swVersion = icoDevice.sw_version;\n                            }\n                            if (needsUpdate) {\n                                await this.setObjectAsync(device._id, device);\n                            }\n\n                            this.devices.push({\n                                poolId: pool.id as number,\n                                swVersion: icoDevice.sw_version,\n                                uuid: icoDevice.uuid,\n                                hasObjects: {},\n                            });\n                            //remove device from devices array:\n                            const index = devices.indexOf(device);\n                            if (index >= 0) {\n                                devices.splice(index, 1);\n                            }\n                            break;\n                        }\n                    }\n\n                    //create device from pool / device if necessary\n                    if (!found) {\n                        const id = `${this.namespace}.${icoDevice.uuid}`;\n                        const deviceObj = {\n                            type: 'device' as const,\n                            common: {\n                                name: <string>pool.name,\n                            },\n                            native: {\n                                poolId: pool.id as number,\n                                swVersion: icoDevice.sw_version,\n                            },\n                        };\n                        this.devices.push({\n                            poolId: deviceObj.native.poolId,\n                            swVersion: deviceObj.native.swVersion,\n                            hasObjects: {},\n                            uuid: icoDevice.uuid,\n                        });\n                        await this.setObjectAsync(id, deviceObj);\n                    }\n                } catch (e: any) {\n                    this.log.error(\n                        `Could not update pool ${pool.id}: ${e}. If network error, retry later. Otherwise, please try to login again.`,\n                    );\n                    deleteAllowed = false;\n                }\n            }\n        }\n\n        //if we still have devices, those are not in the cloud anymore -> remove.\n        if (deleteAllowed) {\n            for (const device of devices) {\n                this.log.debug(`Deleting device ${device._id}`);\n                await this.delObjectAsync(device._id.split('.').pop() as string, { recursive: true });\n            }\n        } else {\n            //fill this.devices from remaining objects:\n            for (const deviceObj of devices) {\n                this.devices.push({\n                    poolId: deviceObj.native.poolId,\n                    swVersion: deviceObj.native.swVersion,\n                    hasObjects: {},\n                    uuid: deviceObj._id.split('.').pop() || '',\n                });\n            }\n        }\n    }\n\n    private async createObjectForMeasurement(device: myDevice, type: PossibleTypes): Promise<void> {\n        let role = 'state';\n        let unit: string | undefined = undefined;\n        switch (type) {\n            case 'temperature': {\n                role = 'value.temperature';\n                unit = '\u00B0C';\n                break;\n            }\n            case 'ph': {\n                role = 'value';\n                break;\n            }\n            case 'orp': {\n                role = 'value';\n                unit = 'mV';\n                break;\n            }\n            case 'salt': {\n                role = 'value';\n                unit = 'mg/L';\n                break;\n            }\n            case 'tds': {\n                role = 'value';\n                unit = 'ppm';\n                break;\n            }\n            case 'battery': {\n                role = 'value.battery';\n                unit = '%';\n                await this.setObjectNotExistsAsync(`${device.uuid}.lowBat`, {\n                    type: 'state',\n                    common: {\n                        name: 'Low battery warning',\n                        role: 'indicator.lowbat',\n                        type: 'boolean',\n                        read: true,\n                        write: false,\n                    },\n                    native: {},\n                });\n                break;\n            }\n            case 'rssi': {\n                role = 'value.rssi';\n                unit = '%';\n                await this.setObjectNotExistsAsync(`${device.uuid}.offline`, {\n                    type: 'state',\n                    common: {\n                        name: 'Low wifi signal',\n                        role: 'indicator.maintenance.unreach',\n                        type: 'boolean',\n                        read: true,\n                        write: false,\n                    },\n                    native: {},\n                });\n                break;\n            }\n        }\n        const id = `${device.uuid}.${type}`;\n        const stateObj: ioBroker.SettableObject = {\n            type: 'state',\n            common: {\n                name: type,\n                type: 'number',\n                role: role,\n                read: true,\n                write: false,\n                unit: unit,\n            },\n            native: {},\n        };\n        device.hasObjects[type] = true;\n        await this.setObjectNotExistsAsync(id, stateObj);\n    }\n\n    private async updateMeasurementsOfDevice(device: myDevice): Promise<void> {\n        try {\n            const measures = await this.api!.getLastMeasures(device.poolId);\n            const promises: Array<Promise<any>> = [];\n            for (const measure of measures) {\n                if (measure.is_valid) {\n                    if (!device.hasObjects[measure.data_type]) {\n                        await this.createObjectForMeasurement(device, measure.data_type);\n                    }\n                    const currState = await this.getStateAsync(`${device.uuid}.${measure.data_type}`);\n                    if (!currState || currState.ts < measure.value_time.getTime()) {\n                        this.log.debug(`Got new Measurement for ${measure.data_type}: ${measure.value}`);\n                        await this.setStateAsync(`${device.uuid}.${measure.data_type}`, {\n                            val: measure.value,\n                            ack: true,\n                            ts: measure.value_time.getTime(),\n                        });\n                        if (measure.data_type === 'battery') {\n                            await this.setStateChangedAsync(`${device.uuid}.lowBat`, {\n                                val: measure.value < 20, //TODO: evaluate or make configurable...\n                                ack: true,\n                                ts: measure.value_time.getTime(),\n                            });\n                        }\n                        if (measure.data_type === 'rssi') {\n                            await this.setStateChangedAsync(`${device.uuid}.offline`, {\n                                val: measure.value < 5, //TODO: evaluate or make configurable...\n                                ack: true,\n                                ts: measure.value_time.getTime(),\n                            });\n                        }\n                    } else {\n                        this.log.debug(`Measurement for ${measure.data_type} was already recorded in state db.`);\n                    }\n                } else {\n                    //can be {\"slug\":\"ICO_OUT_OF_WATER\"} -> maybe record to some error state?\n                    this.log.debug(\n                        `Did not read ${measure.data_type} for ${device.poolId} because ${JSON.stringify(measure.exclusion_reason)}`,\n                    );\n                }\n            }\n            await Promise.all(promises);\n        } catch (e: any) {\n            this.log.warn(`Could not get measurements: ${e}`);\n        }\n    }\n\n    /**\n     * Update recommendations for device.\n     *\n     * @param device - device to update\n     */\n    private async updateRecommendationsOfDevice(device: myDevice): Promise<void> {\n        try {\n            const recommendations = await this.api!.getRecommendations(device.poolId);\n            //make sure channel exists.\n            await this.setObjectNotExistsAsync(`${device.uuid}.recommendations`, {\n                type: 'channel',\n                common: {\n                    name: 'Recommendations',\n                },\n                native: {},\n            });\n            let lastRecommendation;\n            //create and update states\n            for (const recommendation of recommendations) {\n                await this.setObjectNotExistsAsync(`${device.uuid}.recommendations.${recommendation.id}`, {\n                    type: 'state',\n                    common: {\n                        name: recommendation.id.toString(10),\n                        type: 'string',\n                        role: 'text',\n                        read: true,\n                        write: false,\n                    },\n                    native: {},\n                });\n                await this.setState(`${device.uuid}.recommendations.${recommendation.id}`, recommendation.title, true);\n\n                //keep track of latestRecommendation\n                if (\n                    !lastRecommendation ||\n                    recommendation.updated_at.getTime() > lastRecommendation.updated_at.getTime()\n                ) {\n                    lastRecommendation = recommendation;\n                }\n            }\n\n            if (lastRecommendation) {\n                await this.setObjectNotExistsAsync(`${device.uuid}.recommendations.lastRecommendation`, {\n                    type: 'state',\n                    common: {\n                        name: 'Last recommendation',\n                        type: 'string',\n                        role: 'text',\n                        read: true,\n                        write: false,\n                    },\n                    native: {},\n                });\n                await this.setState(\n                    `${device.uuid}.recommendations.lastRecommendation`,\n                    lastRecommendation.title,\n                    true,\n                );\n            }\n\n            // clean up old recommendation objects:\n            const recommendationObjects = await this.getStatesAsync(`${device.uuid}.recommendations.*`);\n            for (const id of Object.keys(recommendationObjects)) {\n                let found = false;\n                if (!id.includes('lastRecommendation')) {\n                    const recId = Number(id.split('.').pop());\n                    for (const recommendation of recommendations) {\n                        if (recommendation.id === recId) {\n                            found = true;\n                            break;\n                        }\n                    }\n\n                    if (!found) {\n                        this.log.debug(`Deleting recommendation ${id}`);\n                        await this.delObjectAsync(id, { recursive: true });\n                    }\n                }\n            }\n        } catch (e: any) {\n            this.log.warn(`Could not get recommendations: ${e}`);\n        }\n    }\n\n    private async poll(): Promise<void> {\n        this.log.debug('Polling');\n        const promises: Array<Promise<any>> = [];\n        for (const device of this.devices) {\n            promises.push(this.updateMeasurementsOfDevice(device));\n            promises.push(this.updateRecommendationsOfDevice(device));\n        }\n        await Promise.all(promises);\n        this.log.debug(`Update done.`);\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback - callback function\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.unloaded = true;\n            for (const sleep of this.sleeps) {\n                clearTimeout(sleep);\n            }\n            callback();\n        } catch (e: any) {\n            console.error('Error during unloading:', e);\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    //     if (obj) {\n    //         // The object was changed\n    //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    //     } else {\n    //         // The object was deleted\n    //         this.log.info(`object ${id} deleted`);\n    //     }\n    // }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    // private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n    //     if (state) {\n    //         // The state was changed\n    //         this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n    //     } else {\n    //         // The state was deleted\n    //         this.log.info(`state ${id} deleted`);\n    //     }\n    // }\n\n    /**\n     * Store new tokens in adapter config.\n     *\n     * @param accessToken - access token\n     * @param refreshToken - refresh token\n     * @param noAdapterRestart - if true, don't restart adapter otherwise writing the config object will trigger a restart.\n     */\n    async storeNewTokens(\n        accessToken: string | undefined,\n        refreshToken: string | undefined,\n        noAdapterRestart = false,\n    ): Promise<ioBroker.InstanceObject> {\n        //get secret for encryption:\n        const systemConfig = await this.getForeignObjectAsync('system.config');\n        const secrect = systemConfig?.native?.secret || 'RJaeBLRPwvPfh5O';\n        const instance = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n        //encrypt tokens:\n        instance!.native.accessToken = accessToken\n            ? encryptDecrypt(secrect, accessToken)\n            : instance!.native.accessToken;\n        instance!.native.refreshToken = refreshToken\n            ? encryptDecrypt(secrect, refreshToken)\n            : instance!.native.refreshToken;\n        if (!noAdapterRestart) {\n            await this.setForeignObject(`system.adapter.${this.namespace}`, instance!);\n        }\n        return instance!;\n    }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    /**\n     * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n     * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n     *\n     * @param obj - message object\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj === 'object' && obj.message) {\n            this.log.debug(`Message: ${JSON.stringify(obj)}`);\n            if (obj.command === 'getOAuthStartLink') {\n                const baseUrl = obj.message.redirectUriBase;\n                this.redirectURI = `${baseUrl}oauth2_callbacks/${this.namespace}/`; // redirect URI that ondilo should call\n                this.oauthStateCode = `ico-cloud-${Math.floor(Math.random() * 100000)}-${Date.now()}`; // random state code\n                this.log.debug(`Got redirect URI: ${this.redirectURI}. Storing state ${this.oauthStateCode}`);\n                const loginUrl = Api.getLoginUrl(this.redirectURI, this.oauthStateCode);\n                this.log.debug(`Got login URL: ${loginUrl}`);\n                if (obj.callback) {\n                    this.sendTo(obj.from, obj.command, { openUrl: loginUrl }, obj.callback);\n                }\n            }\n\n            if (obj.command === 'oauth2Callback') {\n                this.log.debug(`Got oauth2 callback, trying to get access token. Stored state: ${this.oauthStateCode}`);\n                if (this.oauthStateCode === obj.message.state) {\n                    const result = await Api.getToken(obj.message.code, this.redirectURI, this.log);\n                    if (obj.callback) {\n                        if (result) {\n                            const instance = await this.storeNewTokens(result.accessToken, result.refreshToken, true);\n                            this.sendTo(\n                                obj.from,\n                                obj.command,\n                                { result: 'loginSuccessMessage', native: result, saveConfig: true },\n                                obj.callback,\n                            );\n                            await this.setForeignObject(`system.adapter.${this.namespace}`, instance);\n                        } else {\n                            this.sendTo(obj.from, obj.command, { error: 'loginErrorMessage' }, obj.callback);\n                        }\n                    }\n                } else {\n                    if (obj.callback) {\n                        this.sendTo(obj.from, obj.command, { error: 'loginWrongStateMessage' }, obj.callback);\n                    }\n                }\n            }\n\n            if (obj.command === 'resetTokens') {\n                this.log.debug(`Got reset tokens command.`);\n                if (obj.callback) {\n                    this.sendTo(\n                        obj.from,\n                        obj.command,\n                        {\n                            native: { accessToken: '', refreshToken: '' },\n                            saveConfig: false,\n                        },\n                        obj.callback,\n                    );\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new IcoCloud(options);\n} else {\n    // otherwise start the instance directly\n    (() => new IcoCloud())();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAQA,YAAuB;AAEvB,iBAAwC;AAmBxC,SAAS,eAAe,KAAa,OAAuB;AACxD,MAAI,CAAC,SAAS,CAAC,KAAK;AAChB,WAAO;AAAA,EACX;AACA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,cAAU,OAAO,aAAa,IAAI,IAAI,IAAI,MAAM,EAAE,WAAW,CAAC,IAAI,MAAM,WAAW,CAAC,CAAC;AAAA,EACzF;AACA,SAAO;AACX;AAEA,MAAM,iBAAiB,MAAM,QAAQ;AAAA,EACzB;AAAA,EACA,eAAe;AAAA,EACf,UAA2B,CAAC;AAAA,EAC5B,cAAqC;AAAA,EACrC,WAAW;AAAA,EACX,cAAc;AAAA,EACd,iBAAiB;AAAA,EACjB,SAA2B,CAAC;AAAA,EAE7B,YAAY,UAAyC,CAAC,GAAG;AAC5D,UAAM;AAAA,MACF,GAAG;AAAA,MACH,MAAM;AAAA,IACV,CAAC;AACD,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AAGxC,SAAK,GAAG,WAAW,KAAK,UAAU,KAAK,IAAI,CAAC;AAC5C,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAC9C;AAAA,EAEA,MAAc,MAAM,IAA2B;AAC3C,WAAO,IAAI,QAAQ,aAAW;AAC1B,WAAK,OAAO;AAAA,QACR,WAAW,MAAM;AACb,WAAC,KAAK,YAAY,QAAQ;AAAA,QAC9B,GAAG,EAAE;AAAA,MACT;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,UAAyB;AAInC,UAAM,iBAAiB,MAAM,KAAK,sBAAsB,kBAAkB,KAAK,SAAS,EAAE;AAC1F,QAAI,gBAAgB;AAChB,UAAI,eAAe;AACnB,UAAI,eAAe,OAAO,SAAS,YAAY;AAC3C,uBAAe,OAAO,OAAO;AAC7B,uBAAe;AAAA,MACnB;AACA,UAAI,eAAe,OAAO,aAAa,UAAa,eAAe,OAAO,aAAa,cAAc;AACjG,aAAK,IAAI,KAAK,gFAAgF;AAC9F,uBAAe,OAAO,WAAW,GAAG,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,CAAC;AACpG,uBAAe;AAAA,MACnB;AACA,UAAI,cAAc;AACd,aAAK,IAAI,MAAM,yCAAyC,eAAe,OAAO,QAAQ,EAAE;AACxF,cAAM,KAAK,sBAAsB,eAAe,KAAK,cAAc;AAAA,MACvE;AAAA,IACJ;AAEA,UAAM,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,GAAK;AAC9C,SAAK,IAAI,MAAM,sBAAsB,KAAK,+BAA+B;AACzE,UAAM,KAAK,MAAM,KAAK;AAEtB,QAAI,KAAK,OAAO,cAAc;AAC1B,WAAK,MAAM,IAAI,eAAI;AAAA,QACf,aAAa,KAAK,OAAO;AAAA,QACzB,cAAc,KAAK,OAAO;AAAA,QAC1B,KAAK,KAAK;AAAA,QACV,gBAAgB,KAAK,eAAe,KAAK,IAAI;AAAA,MACjD,CAAC;AAED,WAAK,IAAI,MAAM,mBAAmB;AAClC,UAAI;AACA,cAAM,KAAK,cAAc;AAAA,MAC7B,SAAS,GAAQ;AACb,aAAK,IAAI,KAAK,wFAAwF;AACtG,aAAK,IAAI,MAAM,UAAU,CAAC,EAAE;AAAA,MAChC;AACA,WAAK,IAAI,MAAM,kBAAkB;AACjC,YAAM,KAAK,KAAK;AAChB,WAAK,IAAI,MAAM,iBAAiB;AAChC,WAAK,UAAU;AAAA,IACnB,OAAO;AACH,WAAK,IAAI;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,gBAA+B;AA/HjD;AAgIQ,UAAM,UAAU,MAAM,KAAK,gBAAgB;AAE3C,QAAI;AACJ,QAAI,gBAAgB;AACpB,QAAI;AACA,kBAAY,MAAM,KAAK,IAAK,SAAS;AAAA,IACzC,SAAS,GAAQ;AACb,WAAK,IAAI;AAAA,QACL,+BAA+B,CAAC;AAAA,MACpC;AACA,kBAAY,CAAC;AACb,iBAAW,UAAU,SAAS;AAC1B,YAAI,OAAO,OAAO,IAAI;AAClB,oBAAU,KAAK,EAAE,IAAI,OAAO,OAAO,GAAG,CAAC;AAAA,QAC3C,OAAO;AACH,eAAK,IAAI;AAAA,YACL,SAAQ,sCAAQ,WAAR,mBAAgB,IAAc;AAAA,UAC1C;AACA,0BAAgB;AAAA,QACpB;AAAA,MACJ;AAAA,IACJ;AAGA,eAAW,QAAQ,WAAW;AAC1B,UAAI,KAAK,IAAI;AACT,YAAI;AACA,gBAAM,YAAY,MAAM,KAAK,IAAK,UAAU,KAAK,EAAE;AAEnD,cAAI,QAAQ;AACZ,qBAAW,UAAU,SAAS;AAC1B,kBAAM,OAAO,OAAO,IAAI,MAAM,GAAG,EAAE,IAAI;AACvC,gBAAI,SAAS,UAAU,MAAM;AACzB,sBAAQ;AACR,kBAAI,cAAc;AAClB,kBAAI,OAAO,OAAO,WAAW,KAAK,IAAI;AAClC,8BAAc;AACd,uBAAO,OAAO,SAAS,KAAK;AAAA,cAChC;AACA,kBAAI,OAAO,OAAO,cAAc,UAAU,YAAY;AAClD,8BAAc;AACd,uBAAO,OAAO,YAAY,UAAU;AAAA,cACxC;AACA,kBAAI,aAAa;AACb,sBAAM,KAAK,eAAe,OAAO,KAAK,MAAM;AAAA,cAChD;AAEA,mBAAK,QAAQ,KAAK;AAAA,gBACd,QAAQ,KAAK;AAAA,gBACb,WAAW,UAAU;AAAA,gBACrB,MAAM,UAAU;AAAA,gBAChB,YAAY,CAAC;AAAA,cACjB,CAAC;AAED,oBAAM,QAAQ,QAAQ,QAAQ,MAAM;AACpC,kBAAI,SAAS,GAAG;AACZ,wBAAQ,OAAO,OAAO,CAAC;AAAA,cAC3B;AACA;AAAA,YACJ;AAAA,UACJ;AAGA,cAAI,CAAC,OAAO;AACR,kBAAM,KAAK,GAAG,KAAK,SAAS,IAAI,UAAU,IAAI;AAC9C,kBAAM,YAAY;AAAA,cACd,MAAM;AAAA,cACN,QAAQ;AAAA,gBACJ,MAAc,KAAK;AAAA,cACvB;AAAA,cACA,QAAQ;AAAA,gBACJ,QAAQ,KAAK;AAAA,gBACb,WAAW,UAAU;AAAA,cACzB;AAAA,YACJ;AACA,iBAAK,QAAQ,KAAK;AAAA,cACd,QAAQ,UAAU,OAAO;AAAA,cACzB,WAAW,UAAU,OAAO;AAAA,cAC5B,YAAY,CAAC;AAAA,cACb,MAAM,UAAU;AAAA,YACpB,CAAC;AACD,kBAAM,KAAK,eAAe,IAAI,SAAS;AAAA,UAC3C;AAAA,QACJ,SAAS,GAAQ;AACb,eAAK,IAAI;AAAA,YACL,yBAAyB,KAAK,EAAE,KAAK,CAAC;AAAA,UAC1C;AACA,0BAAgB;AAAA,QACpB;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,eAAe;AACf,iBAAW,UAAU,SAAS;AAC1B,aAAK,IAAI,MAAM,mBAAmB,OAAO,GAAG,EAAE;AAC9C,cAAM,KAAK,eAAe,OAAO,IAAI,MAAM,GAAG,EAAE,IAAI,GAAa,EAAE,WAAW,KAAK,CAAC;AAAA,MACxF;AAAA,IACJ,OAAO;AAEH,iBAAW,aAAa,SAAS;AAC7B,aAAK,QAAQ,KAAK;AAAA,UACd,QAAQ,UAAU,OAAO;AAAA,UACzB,WAAW,UAAU,OAAO;AAAA,UAC5B,YAAY,CAAC;AAAA,UACb,MAAM,UAAU,IAAI,MAAM,GAAG,EAAE,IAAI,KAAK;AAAA,QAC5C,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,2BAA2B,QAAkB,MAAoC;AAC3F,QAAI,OAAO;AACX,QAAI,OAA2B;AAC/B,YAAQ,MAAM;AAAA,MACV,KAAK,eAAe;AAChB,eAAO;AACP,eAAO;AACP;AAAA,MACJ;AAAA,MACA,KAAK,MAAM;AACP,eAAO;AACP;AAAA,MACJ;AAAA,MACA,KAAK,OAAO;AACR,eAAO;AACP,eAAO;AACP;AAAA,MACJ;AAAA,MACA,KAAK,QAAQ;AACT,eAAO;AACP,eAAO;AACP;AAAA,MACJ;AAAA,MACA,KAAK,OAAO;AACR,eAAO;AACP,eAAO;AACP;AAAA,MACJ;AAAA,MACA,KAAK,WAAW;AACZ,eAAO;AACP,eAAO;AACP,cAAM,KAAK,wBAAwB,GAAG,OAAO,IAAI,WAAW;AAAA,UACxD,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC;AACD;AAAA,MACJ;AAAA,MACA,KAAK,QAAQ;AACT,eAAO;AACP,eAAO;AACP,cAAM,KAAK,wBAAwB,GAAG,OAAO,IAAI,YAAY;AAAA,UACzD,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC;AACD;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,KAAK,GAAG,OAAO,IAAI,IAAI,IAAI;AACjC,UAAM,WAAoC;AAAA,MACtC,MAAM;AAAA,MACN,QAAQ;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,QACA,MAAM;AAAA,QACN,OAAO;AAAA,QACP;AAAA,MACJ;AAAA,MACA,QAAQ,CAAC;AAAA,IACb;AACA,WAAO,WAAW,IAAI,IAAI;AAC1B,UAAM,KAAK,wBAAwB,IAAI,QAAQ;AAAA,EACnD;AAAA,EAEA,MAAc,2BAA2B,QAAiC;AACtE,QAAI;AACA,YAAM,WAAW,MAAM,KAAK,IAAK,gBAAgB,OAAO,MAAM;AAC9D,YAAM,WAAgC,CAAC;AACvC,iBAAW,WAAW,UAAU;AAC5B,YAAI,QAAQ,UAAU;AAClB,cAAI,CAAC,OAAO,WAAW,QAAQ,SAAS,GAAG;AACvC,kBAAM,KAAK,2BAA2B,QAAQ,QAAQ,SAAS;AAAA,UACnE;AACA,gBAAM,YAAY,MAAM,KAAK,cAAc,GAAG,OAAO,IAAI,IAAI,QAAQ,SAAS,EAAE;AAChF,cAAI,CAAC,aAAa,UAAU,KAAK,QAAQ,WAAW,QAAQ,GAAG;AAC3D,iBAAK,IAAI,MAAM,2BAA2B,QAAQ,SAAS,KAAK,QAAQ,KAAK,EAAE;AAC/E,kBAAM,KAAK,cAAc,GAAG,OAAO,IAAI,IAAI,QAAQ,SAAS,IAAI;AAAA,cAC5D,KAAK,QAAQ;AAAA,cACb,KAAK;AAAA,cACL,IAAI,QAAQ,WAAW,QAAQ;AAAA,YACnC,CAAC;AACD,gBAAI,QAAQ,cAAc,WAAW;AACjC,oBAAM,KAAK,qBAAqB,GAAG,OAAO,IAAI,WAAW;AAAA,gBACrD,KAAK,QAAQ,QAAQ;AAAA;AAAA,gBACrB,KAAK;AAAA,gBACL,IAAI,QAAQ,WAAW,QAAQ;AAAA,cACnC,CAAC;AAAA,YACL;AACA,gBAAI,QAAQ,cAAc,QAAQ;AAC9B,oBAAM,KAAK,qBAAqB,GAAG,OAAO,IAAI,YAAY;AAAA,gBACtD,KAAK,QAAQ,QAAQ;AAAA;AAAA,gBACrB,KAAK;AAAA,gBACL,IAAI,QAAQ,WAAW,QAAQ;AAAA,cACnC,CAAC;AAAA,YACL;AAAA,UACJ,OAAO;AACH,iBAAK,IAAI,MAAM,mBAAmB,QAAQ,SAAS,oCAAoC;AAAA,UAC3F;AAAA,QACJ,OAAO;AAEH,eAAK,IAAI;AAAA,YACL,gBAAgB,QAAQ,SAAS,QAAQ,OAAO,MAAM,YAAY,KAAK,UAAU,QAAQ,gBAAgB,CAAC;AAAA,UAC9G;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC9B,SAAS,GAAQ;AACb,WAAK,IAAI,KAAK,+BAA+B,CAAC,EAAE;AAAA,IACpD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,8BAA8B,QAAiC;AACzE,QAAI;AACA,YAAM,kBAAkB,MAAM,KAAK,IAAK,mBAAmB,OAAO,MAAM;AAExE,YAAM,KAAK,wBAAwB,GAAG,OAAO,IAAI,oBAAoB;AAAA,QACjE,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,QACV;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AACD,UAAI;AAEJ,iBAAW,kBAAkB,iBAAiB;AAC1C,cAAM,KAAK,wBAAwB,GAAG,OAAO,IAAI,oBAAoB,eAAe,EAAE,IAAI;AAAA,UACtF,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM,eAAe,GAAG,SAAS,EAAE;AAAA,YACnC,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC;AACD,cAAM,KAAK,SAAS,GAAG,OAAO,IAAI,oBAAoB,eAAe,EAAE,IAAI,eAAe,OAAO,IAAI;AAGrG,YACI,CAAC,sBACD,eAAe,WAAW,QAAQ,IAAI,mBAAmB,WAAW,QAAQ,GAC9E;AACE,+BAAqB;AAAA,QACzB;AAAA,MACJ;AAEA,UAAI,oBAAoB;AACpB,cAAM,KAAK,wBAAwB,GAAG,OAAO,IAAI,uCAAuC;AAAA,UACpF,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC;AACD,cAAM,KAAK;AAAA,UACP,GAAG,OAAO,IAAI;AAAA,UACd,mBAAmB;AAAA,UACnB;AAAA,QACJ;AAAA,MACJ;AAGA,YAAM,wBAAwB,MAAM,KAAK,eAAe,GAAG,OAAO,IAAI,oBAAoB;AAC1F,iBAAW,MAAM,OAAO,KAAK,qBAAqB,GAAG;AACjD,YAAI,QAAQ;AACZ,YAAI,CAAC,GAAG,SAAS,oBAAoB,GAAG;AACpC,gBAAM,QAAQ,OAAO,GAAG,MAAM,GAAG,EAAE,IAAI,CAAC;AACxC,qBAAW,kBAAkB,iBAAiB;AAC1C,gBAAI,eAAe,OAAO,OAAO;AAC7B,sBAAQ;AACR;AAAA,YACJ;AAAA,UACJ;AAEA,cAAI,CAAC,OAAO;AACR,iBAAK,IAAI,MAAM,2BAA2B,EAAE,EAAE;AAC9C,kBAAM,KAAK,eAAe,IAAI,EAAE,WAAW,KAAK,CAAC;AAAA,UACrD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SAAS,GAAQ;AACb,WAAK,IAAI,KAAK,kCAAkC,CAAC,EAAE;AAAA,IACvD;AAAA,EACJ;AAAA,EAEA,MAAc,OAAsB;AAChC,SAAK,IAAI,MAAM,SAAS;AACxB,UAAM,WAAgC,CAAC;AACvC,eAAW,UAAU,KAAK,SAAS;AAC/B,eAAS,KAAK,KAAK,2BAA2B,MAAM,CAAC;AACrD,eAAS,KAAK,KAAK,8BAA8B,MAAM,CAAC;AAAA,IAC5D;AACA,UAAM,QAAQ,IAAI,QAAQ;AAC1B,SAAK,IAAI,MAAM,cAAc;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,SAAS,UAA4B;AACzC,QAAI;AACA,WAAK,WAAW;AAChB,iBAAW,SAAS,KAAK,QAAQ;AAC7B,qBAAa,KAAK;AAAA,MACtB;AACA,eAAS;AAAA,IACb,SAAS,GAAQ;AACb,cAAQ,MAAM,2BAA2B,CAAC;AAC1C,eAAS;AAAA,IACb;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCA,MAAM,eACF,aACA,cACA,mBAAmB,OACa;AApgBxC;AAsgBQ,UAAM,eAAe,MAAM,KAAK,sBAAsB,eAAe;AACrE,UAAM,YAAU,kDAAc,WAAd,mBAAsB,WAAU;AAChD,UAAM,WAAW,MAAM,KAAK,sBAAsB,kBAAkB,KAAK,SAAS,EAAE;AAEpF,aAAU,OAAO,cAAc,cACzB,eAAe,SAAS,WAAW,IACnC,SAAU,OAAO;AACvB,aAAU,OAAO,eAAe,eAC1B,eAAe,SAAS,YAAY,IACpC,SAAU,OAAO;AACvB,QAAI,CAAC,kBAAkB;AACnB,YAAM,KAAK,iBAAiB,kBAAkB,KAAK,SAAS,IAAI,QAAS;AAAA,IAC7E;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,UAAU,KAAsC;AAC1D,QAAI,OAAO,QAAQ,YAAY,IAAI,SAAS;AACxC,WAAK,IAAI,MAAM,YAAY,KAAK,UAAU,GAAG,CAAC,EAAE;AAChD,UAAI,IAAI,YAAY,qBAAqB;AACrC,cAAM,UAAU,IAAI,QAAQ;AAC5B,aAAK,cAAc,GAAG,OAAO,oBAAoB,KAAK,SAAS;AAC/D,aAAK,iBAAiB,aAAa,KAAK,MAAM,KAAK,OAAO,IAAI,GAAM,CAAC,IAAI,KAAK,IAAI,CAAC;AACnF,aAAK,IAAI,MAAM,qBAAqB,KAAK,WAAW,mBAAmB,KAAK,cAAc,EAAE;AAC5F,cAAM,WAAW,eAAI,YAAY,KAAK,aAAa,KAAK,cAAc;AACtE,aAAK,IAAI,MAAM,kBAAkB,QAAQ,EAAE;AAC3C,YAAI,IAAI,UAAU;AACd,eAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,SAAS,SAAS,GAAG,IAAI,QAAQ;AAAA,QAC1E;AAAA,MACJ;AAEA,UAAI,IAAI,YAAY,kBAAkB;AAClC,aAAK,IAAI,MAAM,kEAAkE,KAAK,cAAc,EAAE;AACtG,YAAI,KAAK,mBAAmB,IAAI,QAAQ,OAAO;AAC3C,gBAAM,SAAS,MAAM,eAAI,SAAS,IAAI,QAAQ,MAAM,KAAK,aAAa,KAAK,GAAG;AAC9E,cAAI,IAAI,UAAU;AACd,gBAAI,QAAQ;AACR,oBAAM,WAAW,MAAM,KAAK,eAAe,OAAO,aAAa,OAAO,cAAc,IAAI;AACxF,mBAAK;AAAA,gBACD,IAAI;AAAA,gBACJ,IAAI;AAAA,gBACJ,EAAE,QAAQ,uBAAuB,QAAQ,QAAQ,YAAY,KAAK;AAAA,gBAClE,IAAI;AAAA,cACR;AACA,oBAAM,KAAK,iBAAiB,kBAAkB,KAAK,SAAS,IAAI,QAAQ;AAAA,YAC5E,OAAO;AACH,mBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,OAAO,oBAAoB,GAAG,IAAI,QAAQ;AAAA,YACnF;AAAA,UACJ;AAAA,QACJ,OAAO;AACH,cAAI,IAAI,UAAU;AACd,iBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,OAAO,yBAAyB,GAAG,IAAI,QAAQ;AAAA,UACxF;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,IAAI,YAAY,eAAe;AAC/B,aAAK,IAAI,MAAM,2BAA2B;AAC1C,YAAI,IAAI,UAAU;AACd,eAAK;AAAA,YACD,IAAI;AAAA,YACJ,IAAI;AAAA,YACJ;AAAA,cACI,QAAQ,EAAE,aAAa,IAAI,cAAc,GAAG;AAAA,cAC5C,YAAY;AAAA,YAChB;AAAA,YACA,IAAI;AAAA,UACR;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AAEA,IAAI,QAAQ,SAAS,QAAQ;AAEzB,SAAO,UAAU,CAAC,YAAuD,IAAI,SAAS,OAAO;AACjG,OAAO;AAEH,GAAC,MAAM,IAAI,SAAS,GAAG;AAC3B;",
  "names": []
}
