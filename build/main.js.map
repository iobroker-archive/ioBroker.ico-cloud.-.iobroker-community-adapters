{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.1.1\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport {Api, PossibleTypes} from './lib/api';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\ninterface myDevice {\n    poolId: number,\n    swVersion: string,\n    hasObjects: Record<string, boolean>\n    uuid: string\n}\n\nclass IcoCloud extends utils.Adapter {\n    private api?: Api;\n    private pollInterval = 0;\n    private devices: Array<myDevice> = [];\n    private pollTimeout : NodeJS.Timeout | null = null;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'ico-cloud',\n        });\n        this.on('ready', this.onReady.bind(this));\n        // this.on('stateChange', this.onStateChange.bind(this));\n        // this.on('objectChange', this.onObjectChange.bind(this));\n        // this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n        // this.config:\n        this.log.info('Configured pollinterval: ' + this.config.pollinterval);\n        //this.log.info('refreshToken: ' + this.config.refreshToken);\n\n        if (this.config.refreshToken) {\n            this.api = new Api({\n                accessToken: this.config.accessToken,\n                refreshToken: this.config.refreshToken,\n                log: this.log\n            });\n\n            await this.updateDevices();\n\n            if (this.config.pollinterval) {\n                this.pollInterval = Math.max(1, this.config.pollinterval) * 60 * 1000; //convert from minutes to milliseconds.\n                await this.poll();\n            }\n        } else {\n            this.log.info('Not authorized, yet. Please see configuration.');\n        }\n    }\n\n    private async updateDevices() : Promise<void> {\n        const devices = await this.getDevicesAsync();\n\n        try {\n            const poolArray = await this.api!.getPools();\n            for (const pool of poolArray) {\n                if (pool.id) {\n                    const icoDevice = await this.api!.getDevice(pool.id);\n\n                    let found = false;\n                    for (const device of devices) {\n                        const uuid = device._id.split('.').pop();\n                        if (uuid === icoDevice.uuid) {\n                            found = true;\n                            let needsUpdate = false;\n                            if (device.native.poolId !== pool.id) {\n                                needsUpdate = true;\n                                device.native.poolId = pool.id;\n                            }\n                            if (device.native.swVersion !== icoDevice.sw_version) {\n                                needsUpdate = true;\n                                device.native.swVersion = icoDevice.sw_version;\n                            }\n                            if (needsUpdate) {\n                                await this.setObjectAsync(device._id, device);\n                            }\n\n                            this.devices.push({\n                                poolId: pool.id as number,\n                                swVersion: icoDevice.sw_version,\n                                uuid: icoDevice.uuid,\n                                hasObjects: {}\n                            });\n                            //remove device from devices array:\n                            const index = devices.indexOf(device);\n                            if (index >= 0) {\n                                devices.splice(index, 1);\n                            }\n                            break;\n                        }\n                    }\n\n                    //create device from pool / device if necessary\n                    if (!found) {\n                        const id = this.namespace + '.' + icoDevice.uuid;\n                        const deviceObj = {\n                            type: 'device' as const,\n                            common: {\n                                name: <string>pool.name\n                            },\n                            native: {\n                                poolId: pool.id as number,\n                                swVersion: icoDevice.sw_version\n                            }\n                        }\n                        this.devices.push({\n                            poolId: deviceObj.native.poolId,\n                            swVersion: deviceObj.native.swVersion,\n                            hasObjects: {},\n                            uuid: icoDevice.uuid\n                        });\n                        await this.setObjectAsync(id, deviceObj);\n                    }\n                }\n            }\n\n            //if we still have devices, those are not in the cloud anymore -> remove.\n            for (const device of devices) {\n                this.log.debug('Deleting device ' + device._id);\n                await this.deleteDeviceAsync(device._id.split('.').pop() as string); //does this work as intended??\n                /*const objectsToDelete = await this.getObjectListAsync({startkey: device._id + '.', endkey: device._id + '.\\u9999'});\n                const promises = [];\n                for (const obj of objectsToDelete) {\n                    promises.push(this.delObjectAsync(obj._id));\n                }*/\n            }\n        } catch (e) {\n            this.log.error('Could not update devices: ' + e + '. If network error, retry later. Otherwise, please try to login again.');\n            this.terminate('Could not update devices.', utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);\n        }\n    }\n\n    private async createObjectForMeasurement(device: myDevice, type: PossibleTypes) : Promise<void> {\n        let role  = 'state';\n        let unit: string | undefined = undefined;\n        switch (type) {\n            case 'temperature': {\n                role = 'value.temperature';\n                unit = '\u00B0C';\n                break;\n            }\n            case 'ph': {\n                role = 'value'\n                break;\n            }\n            case 'orp': {\n                role = 'value';\n                unit = 'mV';\n                break;\n            }\n            case 'salt': {\n                role = 'value';\n                unit = 'mg/L';\n                break;\n            }\n            case 'tds': {\n                role = 'value';\n                unit = 'ppm';\n                break;\n            }\n            case 'battery': {\n                role = 'value.battery';\n                unit = '%';\n                await this.setObjectNotExistsAsync(device.uuid + '.lowBat', {\n                    type: 'state',\n                    common: {\n                        name: 'Low battery warning',\n                        role: 'indicator.lowbat',\n                        type: 'boolean',\n                        read: true,\n                        write: false\n                    },\n                    native: {}\n                });\n                break;\n            }\n            case 'rssi': {\n                role = 'value.rssi';\n                unit = '%';\n                await this.setObjectNotExistsAsync(device.uuid + '.offline', {\n                    type: 'state',\n                    common: {\n                        name: 'Low wifi signal',\n                        role: 'indicator.maintenance.unreach',\n                        type: 'boolean',\n                        read: true,\n                        write: false\n                    },\n                    native: {}\n                });\n                break;\n            }\n        }\n        const id  = device.uuid + '.' + type;\n        const stateObj : ioBroker.SettableObject = {\n            type: 'state',\n            common: {\n                name: type,\n                type: 'number',\n                role: role,\n                read: true,\n                write: false,\n                unit: unit\n            },\n            native: {},\n        }\n        device.hasObjects[type] = true;\n        await this.setObjectNotExistsAsync(id, stateObj);\n    }\n\n    private async updateMeasurementsOfDevice(device: myDevice) : Promise<void> {\n        try {\n            const measures = await this.api!.getLastMeasures(device.poolId);\n            const promises: Array<Promise<any>> = [];\n            for (const measure of measures) {\n                if (measure.is_valid) {\n                    if (!device.hasObjects[measure.data_type]) {\n                        await this.createObjectForMeasurement(device, measure.data_type);\n                    }\n                    const currState = await this.getStateAsync(device.uuid + '.' + measure.data_type);\n                    if (!currState || currState.ts < measure.value_time.getTime()) {\n                        this.log.debug(`Got new Measurement for ${measure.data_type}: ${measure.value}`);\n                        await this.setStateAsync(device.uuid + '.' + measure.data_type, {\n                            val: measure.value,\n                            ack: true,\n                            ts: measure.value_time.getTime()\n                        });\n                        if (measure.data_type === 'battery') {\n                            await this.setStateChangedAsync(device.uuid + '.lowBat', {\n                                val: measure.value < 20, //TODO: evaluate or make configurable...\n                                ack: true,\n                                ts: measure.value_time.getTime()\n                            });\n                        }\n                        if (measure.data_type === 'rssi') {\n                            await this.setStateChangedAsync(device.uuid + '.offline', {\n                                val: measure.value < 5, //TODO: evaluate or make configurable...\n                                ack: true,\n                                ts: measure.value_time.getTime()\n                            });\n                        }\n                    } else {\n                        this.log.debug(`Measurement for ${measure.data_type} was already recorded in state db.`);\n                    }\n                } else {\n                    this.log.debug(`Did not read ${measure.data_type} for ${device.poolId} because ${JSON.stringify(measure.exclusion_reason)}`);\n                }\n            }\n            await Promise.all(promises);\n        } catch (e) {\n            this.log.warn('Could not get measurements: ' + e);\n        }\n    }\n\n    private async poll() : Promise<void> {\n        this.log.debug('Polling');\n        const promises: Array<Promise<any> > = [];\n        for (const device of this.devices) {\n            promises.push(this.updateMeasurementsOfDevice(device));\n        }\n        await Promise.all(promises);\n        this.log.debug(`Update done. Polling again in ${this.pollInterval}`);\n        this.pollTimeout = setTimeout(() => {\n            this.poll();\n        }, this.pollInterval);\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            if (this.pollTimeout) {\n                clearTimeout(this.pollTimeout);\n            }\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    //     if (obj) {\n    //         // The object was changed\n    //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    //     } else {\n    //         // The object was deleted\n    //         this.log.info(`object ${id} deleted`);\n    //     }\n    // }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    // private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n    //     if (state) {\n    //         // The state was changed\n    //         this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n    //     } else {\n    //         // The state was deleted\n    //         this.log.info(`state ${id} deleted`);\n    //     }\n    // }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    // private onMessage(obj: ioBroker.Message): void {\n    //     if (typeof obj === 'object' && obj.message) {\n    //         if (obj.command === 'send') {\n    //             // e.g. send email or pushover or whatever\n    //             this.log.info('send command');\n\n    //             // Send response in callback if required\n    //             if (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n    //         }\n    //     }\n    // }\n\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new IcoCloud(options);\n} else {\n    // otherwise start the instance directly\n    (() => new IcoCloud())();\n}"],
  "mappings": "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",
  "names": []
}
